# DataAccess(数据存取)

`Javascript`中有四种基本的数据存取位置：
+ 字面量：只代表自身，不存储在特定的位置。如,字符串、数字、布尔值、对象、数组、函数、正则表达式,以及特殊的`null`和`undefined`
+ 本地变量：使用`var`定义的数据存储单元
+ 数组元素：数组对象内部，以数字作为索引
+ 对象成员：对象内部，以字符串作为索引

大多数情况字面量和局部变量中存取数据性能差异微不足道,访问数组和对象成员代价更高。所以尽量减少数组项和对象成员的使用。

## 管理作用域

### 作用域链和标识符解析
每一个`javascript`函数都表示为一个对象——`Function`对象的一个实例。它拥有一个不能通过代码访问而供`javascript`引擎存取的内部属性`[[Scope]]`(部分浏览器可以访问)
`[[Scope]]`包含了一个函数被创建的作用域中对象的集合，这个集合就是函数的作用域链，它决定哪些数据能被函数访问

当一个函数被创建后，它的`[[Scope]]`属性会被创建此函数的当前作用域的变量对象填充，该变量对象包含当前作用域中所有可访问的变量。

执行函数时会创建一个称为执行环境的内部对象(独一无二)。当函数执行完毕时，执行环境销毁。
每个执行环境都有自己的作用域链，用于解析标识符。当执行环境被创建时，它的作用域链初始化为当前运行函数的`[[Scope]]`属性中的对象。活动对象即是处于当前执行环境的变量对象，包含了所以局部变量、命名参数、参数合集以及this。然后此对象被推入作用域最顶端，直到执行环境被销毁时一同销毁。

每遇到一个变量都会经历一次标识符解析过程以决定从哪里获取或存储数据，该过程从当前执行环境开始向上查找直到找到，未找到时视为`undefined`，这个搜索过程影响了性能。


### 标识符解析的性能
标识符解析具有代价，在执行环境的作用域链中，标识符所在位置越深，它的读写速度越慢。所以读写局部变量小于全局变量。
在没有优化`Javascript`引擎的浏览器中，尽可能使用局部变量。
**Note**：如果某个跨作用域的值在函数中被引用一次以上，那么最好把它存储在局部变量中。

### 改变作用域链
`with`语句可以临时改变作用域链。`with`语句用来给对象的所有属性创建一个变量，用于比避免重复书写代码。

问题：当代码执行到`with`语句时，执行环境作用域链临时改变。一个新的变量对象被创建且包含了参数指定的对象的所有属性。这个对象被推入作用域链顶端，这意味着函数的所有局部变量都处于作用域链的下一层对象中，提高了访问的代价。

`try...catch`语句的`catch`子句也有同样效果。当`try`发生错误时，执行环境会跳转到`catch`子句并把异常对象推入作用域链顶端，其他局部变量放入第二层作用域，执行完毕后销毁顶层作用域。

对于`catch`语句的问题，可以将错误委托给一个函数来处理，就避免了局部变量的访问且不会影响性能，如：
```js
try{
  //....
}catch(e){
  handleError(e);
}
```

### 动态作用域
动态作用域只存在于代码执行过程中，因此无法静态分析(查看代码结构)，如with,try-catch,eval

```js
function one(params) {
  eval(params);

  function two() {
    return window;
  }

  var w = two();

  console.log(w);
}
  one('var window = {};');//w = {}
```

必要时才推荐使用动态作用域

### 闭包、作用域和内存
由于闭包的`[[Scope]]`属性包含了与执行环境作用域链相同的对象的引用，所以*需要更多的内存*。一般情况，函数的活动对象在执行完后会随着执行环境一同销毁，但引入闭包时，闭包仍保持着对活动对象的引用，因此无法销毁。

当闭包代码执行时，会创建一个执行环境，它的作用域链与属性`[[Scope]]`中所引用的相同的作用域链对象一起被初始化，然后活动对象为闭包自身创建。

问题：在*频繁访问跨作用域的标识符*时，每次访问都会带来性能损失。

## 对象成员

### 原型
原型是对象的基础。对象拥有两类成员类型：实例成员和原型成员————实例成员即直接存在于对象实例中，原型成员继承二来。

### 原型链
对象的原型决定了实例的类型。
搜索实例成员比从字面量和局部变量读取代价高，再加上遍历原型链带来的开销，代价更大。

### 嵌套成员
对象成员嵌套越深，读取速度越慢。每次遇到.操作符都会导致`javascript`引擎搜索所有对象成员。且如果这些属性不是实例属性则要搜索原型链，花费更多时间。
`location.href`总比`window.location.href`要快
Note：大部分浏览器括号表示法和点标识符访问对象快慢没有明显区别，部分浏览器点标识符始终快于括号表示法。

### 缓存对象成员值
如果在函数中多次读取同一个对象属性，那么最好将它保存在局部变量中。请不要在同一函数中多次查找同一对象成员，除非它值改变。

