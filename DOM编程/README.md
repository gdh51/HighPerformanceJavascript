# DOM编程

本章讨论3个问题
+ 访问和修改DOM元素
+ 修改DOM元素的样式会导致重绘和重排
+ 通过DOM事件处理与用户交互

## 浏览器中的DOM
浏览器通常会把DOM和Javascript独立实现

### 天生就满
两个相互独立的功能只要通过接口彼此连接就会产生消耗

## DOM访问和修改
修改元素会导致浏览器重新计算页面的几何变化。
Note：减少访问DOM的次数，把运算尽量留在ES处理。

### innerHTML对比DOM方法
在绝大多数浏览器中`innerHTML`比操作DOM运行速度更快，但随着浏览器更新两者区别缩小有时有所反超。

### 节点克隆
使用DOM方法更新页面内容有时可以使用`cloneNode()`方法代替`createElement()`，在绝大多数浏览器中该方法更有效率但不是非常明显。

### HTML集合
例如`document.getElementsByName`、`document.images`之类所取得的集合。它们都是以一种假定实时态实时存在，每次当我们对其查询时，它都会重复执行查询过程(即使是`length`属性)，所以导致低效。

遍历数组快于集合，如果先将集合拷贝到数组中，那么访问它的属性就会更快，但会额外多遍历一次集合，所以请结合情况使用数组拷贝。

当然不要忘记用局部变量存储集合

### 遍历DOM

#### 获取DOM元素
当从一个DOM元素开始，查找元素中所有的子节点，可以通过遍历`childNodes`和`nextSibling`来完成，两者的效率差不多，只有在较老版本的IE下`nextSibling`更占优势。

#### 元素节点
通过相关直接的API获取元素结点比自己手动过滤不是元素的结点高效，但前提是浏览器支持API。

#### 选择器API
`document.querySelector`方法查找元素比遍历查找更加高效，该方法返回的`NodeList`不会对应实时的文档结构。前提是支持。

## 重绘和重排
浏览器下载完页面中的所有组件————HTML标记、javascript、CSS、图片————之后会解析并生成两个内部数据结构：
**DOM树**：表示页面结构
**渲染数**：表示DOM节点如何显示

DOM树中的每一个需要显示的节点在渲染树中至少存在一个对应的节点(隐藏的DOM元素没有)。一旦DOM和渲染树构建完成，浏览器就开始显示(绘制)页面元素

当DOM的变换影响了元素的几何属性————比如改变元素盒子大小，浏览器都会重新计算元素的几何属性，同样其他属性和位置也会受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为**重排(reflow回流)**。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为**重绘(repaint)**。

总之两者代价都非常高，会导致UI反应迟钝，应该避免。

### 重排(回流)何时发生
当页面布局和几何属性改变时就需要回流：
+ 添加或删除可见DOM元素
+ 元素位置改变
+ 元素尺寸改变
+ 内容改变
+ 页面渲染器初始化
+ 浏览器窗口尺寸改变

### 渲染树变化的排队与刷新
每次回流都会产生计算消耗，大多数浏览器通过队列化修改并批量执行来优化重排过程。有时我们会在不轻易间强制刷新队列并要求计划任务立刻执行。获取布局信息的操作会导致队列刷新：
+ `offsetTop`,`offsetLeft`,`offsetWidth`,`offsetHeight`
+ `scrollTop`,`scrollLeft`,`scrollWidth`,`scrollHeight`
+ `clientTop`,`clientLeft`,`clientWidth`,`clientHeight`
+ `getComputedStyle()` (`currentStyle` in IE)
以上属性和方法需要返回最新的布局信息，因此浏览器必须执行渲染队列的待处理变化并触发回流以返回正确的值。

一个更有效率的方法是不要在布局信息改变时查询它，延迟布局信息的访问可以带来性能的提升。

### 最小化重绘和重排
合并多次对DOM和样式的修改，然后一次性处理掉。
```js
var el = document.getElementById('div');
el.style.borderLeft = '1px';
el.style.borderRigth = '1px';
el.style.padding = '5px';
```
以上最差的情况会发生3次回流(现在浏览器可能只会触发一次),且有4次DOM的访问，下面是优化：
```js
//覆盖式添加
var el = document.getElementById('div');
el.style.cssText = 'border-left: 1px; border-right: 2px; padding: 5px;';

//保留原样式
var el = document.getElementById('div');
el.style.cssText += '; border-left: 1px; border-right: 2px; padding: 5px;';
```
当然还有另一种方法就是直接添加一个class属性

#### 批量修改DOM
当需要对`DOM`元素操作时，可以有以下步骤来减少回流与重绘：
1. 使元素脱离文档流
2. 对其应用多重改变
3. 把元素带回文档
在该过程中1 3 步操作会导致回流，但没有该两步，2 中任何操作都会导致回流。

DOM脱离文档方法：
+ 隐藏元素，应用修改，重新显示
+ 使用文档片断，在当前`DOM`之外构建一个子树，再把它拷贝回文档
+ 将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换原始元素。

### 缓存布局信息
查询一次样式信息后用局部变量缓存

### 让元素脱离动画流
当一个动画推移整个页面时会导致一个代价昂贵的回流，其效果就是感觉卡顿。
可以通过以下步骤来避免页面中大部分回流：
1. 使用绝对位置定位上的动画元素，将其脱离文档流
2. 让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生回流并重绘页面的大部分内容。
3. 当动画结束时恢复定位，从而只会下移一次文档的其他元素。

### IE和:hover
大量元素使用`:hover`会降低响应速度。在元素很多时避免使用这种效果。

## 事件委托
减少事件监听器个数。
原理：事件逐层冒泡并能被父元素捕获。但要注意跨浏览器兼容(主要是IE):
+ 访问事件对象，并判断事件源
+ 取消文档树中的冒泡(可选)
+ 阻止默认动作(可选)