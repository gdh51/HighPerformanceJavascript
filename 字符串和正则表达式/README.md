# StringsAndRegularExpressions(字符串和正则表达式)

## 字符串连接
除IE7及早期浏览器之外，都进行了比较好的优化

### +或+=操作符

```js
str += 'two' + 'one';
```
上面表达式运行时经历了四个步骤：
1. 在内存中创建一个临时字符串
2. 连接后的字符串twoone赋值给这个临时字符串
3. 临时字符串与str当前的值连接
4. 结果赋值给str

下面进行优化：
```js
str += 'two';
str += 'one';
```

经过上面的步骤，避免了产生临时字符串，提高了性能，实际上可以改写为与 1 类似的写法：
```js
str = str + 'two' + 'one';
```

但如果调换顺序为如下，就失效了：
```js
str = 'one' + str + 'two';
```
在浏览器合并字符串时会分配内存。除IE外，其他浏览器会尝试为表达式左侧的字符串分配更多的空间，然后简单的将第二个字符串拷贝至它的末尾。(基础字符串可以理解为连接时排在最前面的字符串)

在IE8以下的浏览器中，连接操作由底层机制决定。每连接一对字符串都要把它复制到一块新的内存中。所以建议先合并小的字符串在连接(相当于未优化前的代码写法)
在IE8中，连接字符串只记录现有字符串的引用来构造新字符串。在最后时刻，字符串的各个部分才会逐步拷贝到一个新的字符串中。

### 数组项合并
在其他浏览器中，使用数组的join方法来合并字符串明显效率低于直接的字符串拼接，但在IE7及其以下中，这个方法性能更好。

对于String.prototype.concat()方法也比直接的拼接更慢一些

## 正则表达式优化
正则表达式受许多因素的影响：
+ 部分匹配时间 > 完全不匹配所用时间
+ 不同浏览器对正则表达式引擎有着不同程度的内部优化

### 正则表达式工作原理
1. **编译**：当创建一个正则表达式对象后，浏览器会验证后转换为一个原生代码程序。把正则表达式对象复制给一个变量可以避免重复执行这一步骤。

2. **设置起始位置**：当正则表达式进入使用状态，首先要确定目标字符串的起始搜索位置。它由正则表达式对象的lastIndex属性指定，当经历 *步骤4* 后时，该值会变为最后一次匹配的起始位置的下一位字符串的位置。(浏览器的优化方法就是通过提前决定跳过一些不必要的步骤)

3. **匹配每个正则表达式字元**：一旦正则表达式知道开始位置，它会逐个检查文本和正则表达式模式。当一个特定的字元匹配失败时，正则表达式会试着**回溯**到之前尝试匹配的位置上，然后尝试其他的可能的路径。

4. **匹配成功或失败**：当发现一个完全匹配时，就表示匹配成功。如果所有路径都没有匹配则回退到第二步，然后从下一个字符重新尝试。当所有的字符都匹配失败时，就彻底失败。

Note：正则表达式的lastIndex属性值只作为exec和test方法的起始搜索位置，并当且仅当正则表达式含有/g标识时。

### 理解回溯
当正则表达式匹配目标字符串时，它从左到右逐个测试正则表达式的组成部分，看是否能找到匹配项。当遇到量词和分支时————遇到量词时(*,+?,{2,}...)，正则表达式需决定合适尝试匹配更多字符;遇到分支时(|操作符),必须从可选项中选择一个尝试匹配。

每当正则表达式做出类似的决定时，如果有必要都会记录其他选择，以备返回时使用。如果当前选项匹配成功，正则表达式继续扫描表达式，如果其他部分也匹配成功，那么匹配结束。但如果当前选项找不到匹配值，或后面的部分匹配失败，那么正则表达式会回溯到最后一个决策点，然后在剩余的选项中选择一个。一个过程一直进行，直到找到匹配项或其他分支都尝试失败，那么它就会放弃匹配，转而移动到字符串中下一个字符，再次重复该过程。

#### 分支与回溯
给出一个例子，帮助理解回溯
```js
/h(ello|appy) hippo/.test('hello there, happy hippo');
```

很明显这个正则表达式匹配`hello hippo`或`happy hippo`，下面分析执行过程：匹配开始时，首先查找一个`h`，*目标字符串*恰好是`h`与齐匹配。接下来子表达式`(ello|appy)`提供了两个分支，正则表达式先选择左侧分支(分支选择总是从左到右)，然后检查*目标字符串*的下一个字符是否匹配，匹配成功，随后正则表达式匹配后面的空格都成功，直到匹配到*目标字符串*的`t`，与正则表达式的`h`不匹配。此时回到分支开头，尝试第二个分支，也匹配失败。

此时正则表达式认为从*目标字符串*第一个字符开始不能成功，于是从第二个字符开始，一直重复上述过程直到搜索到14个字符位置匹配到`happy`中的`h`，并在第二个分支时成功匹配全部

#### 重复与回溯
同样，给出一个例子：
```js
var str = "<p>Para 1.</p>" +
          "<img src='smiley,jpg'>" +
          "<p>Para 2.</p>" +
          "<div>Div.</div>";
/<p>.*<\/p>/i.test(str);
```

这个正则表达式一开始就匹配了*目标字符串*的前三个字符`<p>`，然后匹配` .* `。(` . `匹配除换行符外的所有字符,贪婪量词星号(` * `)表示匹配重复零次或多次————尽可能匹配多次,这就是贪婪的意思)  因为*目标字符串*没有换行符号，所以匹配其他的所有字符，但由于正则表达式中还有内容需要匹配，因此它开始尝试匹配`<` 。

`<`在*目标字符串*末尾匹配失败，于是正则表达式每次便回溯一个字符，继续尝试匹配`<`，直到遇到`</div>`的首字母`<`，便开始匹配正则表达式中之后的表达式，这里是`/`，匹配成功，在匹配正则表达式的`p`，与*目标字符串* `d`匹配失败，此时正则表达式回溯到首字母`<`，继续向前匹配，重复这个过程，直到匹配到倒数第二行的</p>，结束匹配，但匹配结果貌似不是我们预想中的。

这里可以通过将贪婪量词号` * `替换为非贪婪量词` *? `,来尽可能少的匹配匹配项。非贪婪量词的回溯工作是以相反的方式进行的。当正则表达式匹配到`.*?`时，它先尝试全部跳过并直接匹配接下来的`<\/p>`。这里`.*?`尽可能的匹配零次。但是，当紧挨这的`<`无法匹配当前字符，正则表达式则会回溯并尝试匹配下一个最小值 1 次。它像这样继续向前回溯，直到第一排末尾，完全匹配。

所有当为如下情况时，非贪婪模式和贪婪模式的匹配过程也是并不一样的：
```js
var str = "<p>Para 1.</p>";
```

### 回溯失控
例子：
```js
/<html>[\s\S]*?<head>[\s\S]*?<title>[\s\S]*?<\/title>[\s\S]*?<\/head>
[\s\S]*?<body>[\s\S]*?<\/body>[\s\S]*?<\/html>/
```

上面的正则表达式来匹配常规的`HTML`字符串时运行正常，但是当目标字符串缺少一个或多个标签时就很要命了。比如当缺少`</html>`标签时，最后一个`[\s\S]*?`将扩展到字符串末尾，但任未找到匹配项，然后依次向前搜索`[\s\S]*?`并记住回溯位置。正则表达式尝试扩展到倒数第二个`[\s\S]*?`————用它匹配由正则表达式的`<\/body>`模式匹配到的那个`</body>`标签————然后继续查找第二个`</body>`标签，直到字符串末尾。当所有步骤都失败时，倒数第三个`[\s\S]*?`将被扩展至字符串末尾，以此类推

#### 解决方案：具体化
解决方案就是尽可能具体化分隔符之间的字符串匹配模式。如模式`".*?"`它用来匹配一个由双引号包围的字符串，通过把过于宽泛的`.*?`替换为具体的`[^"\r\n]*`，就去除了可能发生的几种情况。

虽然这么做可以消除回溯失控，但却降低了成功匹配的速度。

#### 使用预查和反向引用的模拟原子组
原子组：原子组写法`(?>...)`，省略号表示任意正则表达式的模式，它是一种具有特殊反转性的非捕获组。一旦原子组中存在一个正则表达式，该组的任何回溯位置都会被丢弃。(Javascript不支持原子组)

预查：全局匹配的一部分，并不消耗任何字符;而只是检查自己包含的正则符号在当前字符串位置是否匹配。我们可以通过把预查表达式封装在捕获组中并给它添加一个方向引用的方法来避免这个问题。
`(?=(pattern to make atomic))\1`

#### 嵌套量词与回溯失控
嵌套量词指量词出现在一个自身被重复量词修饰的组中。(如:`(x+)*`)

确保正则表达式的两个部分不能对字符串的相同部分进行匹配

### 更多提高正则表达式效率的方法

#### 关注如何让匹配更快失败
正则表达式匹配慢的原因通常是因为匹配失败的过程慢，而不是成功。正则表达式匹配失败的位置比匹配成功的位置要多的多。

#### 正则表达式以简单,必要的字元开始
最理想情况：正则表达式的起始标记应当尽可能快速地测试并排除明显不匹配的位置。通常是用定位符排除

#### 使用量词模式,使它们后面的字元互斥
当字符与字元相邻或子表达式能够重叠匹配时，正则表达式尝试拆解文本的路径数量将增加。

#### 减少分支数量,缩小分支范围
分支使用|可能要求在字符串的每一个位置上测试所有分支选项。通常我们可以用字符集和选项组件来减少对分支的需求,或将分支在正则表达式的位置推后.如：
| 替换前 | 替换后 |
| ------ | ------ |
| cat|bat | \[cb\]at |
| red|read | rea?d |
| red|raw | r(?:ed|aw) |
| (.|\r|\n) | \[\s\S\] |

字符集比分支快得多，因为它使用位向量而不是回溯

#### 使用非捕获组
捕获组消耗时间和内存来记录反向引用，并使它们保存最新

#### 只捕获感兴趣的文本以减少后处理
当需要引用匹配的一部分，应采取一切手段捕获那些片段，再使用反向引用来处理。

#### 暴露必须的字元
让正则表达式引擎更容易判断那些字元是必须的。如`/^(ab|cb)/`,这个正则表达式暴露了起始锚,有些浏览器在不匹配起始锚指定范围后，就不进行多余的匹配了。但如`/(^ab|^cd)/`没有暴露，就会进行更多的匹配

#### 使用合适的量词
就像之前的例子一样，同一个例子用贪婪和不贪婪的方法匹配，速度上都有区别，所以要选择合适的量词

#### 把正则表达式复制给变量并重用它们
赋值给变量以避免重新编译。

#### 将复杂的正则表达式拆分为简单的片段
避免在一个正则表达式中处理太多的任务，以免雪崩

### 何时不使用正则表达式
当只是搜索字面字符串时没有必要，有时反而浪费时间。

## 去除字符串首尾空白

### 使用正则表达式去首尾空白

最优写法：使用两个子表达式来去除
```js
if(!String.prototype.trim){
  String.prototype.trim = function (){
    return this.replace(/^\s+/,'').replace(/\s+$/,'');
  }
}
```

其他写法

```js
String.prototype.trim = function(){
  return this.replace(/^\s*([\s\S]*\S)?\s*$/,'$1');
}
```
这个在部分浏览器更快的原因在于浏览器对能匹配任意字符的贪婪重复有着特别的优化